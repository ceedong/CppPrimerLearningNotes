# Chapter-1 Introduction
Some key points in this chapter: 
- address space abstraction(how program and data are structured in address space)
- OS structure: trap and interrupt mechanism 
- creation and destroy of processes in Unix, loading program into processes
- file systems in Unix and access control

## Address Space Abstraction
In unix, every program responds to 4GB address space, 1GB for program and 3GB for kernel.
- text area: placing codes
- data area: placing initialized data info
- bss area: placing uninitilized data info (placing together to initialize them all together at once)
- heap area: placing dynamic allocation memory space 
- stack area: placing local variables/functions info with push() and pop() operations
Above are for user space, and then we got 3GB for kernel space.

## OS structure: Traps & Interrupts
- Application programs call upon the OS via traps:
e.g. system calls | page fault | errors: divided by 0, segmentation fault
- External devices call upon the OS via interrupts:
Most of the hardware interrupts have nothing to do with current processes context and threads, they may change some stuff
in backgrounds
- software interrupt:
Another type different from hardware interrupt, generated by codes to mimic hardware interrupts
- upcall:
The kernel codes can call functions in user modes via upcall mechanism.

## Processes & Threads
- processes is the abstraction of memory and thread is the abstraction of processor.
- introduce several linux system call functions: fork() exec() exit() wait()
- fork(): to create child process, the code space is shared among child and parent process with separate stack and heap spaces
fork() returns twice, once with return code 0, which is the child process, once with pid of child process, which is the parent process<br>
PCB Process Control Block: The kernel data structure to record info for parent and child processes.<br>
4 fields are included in PCB: PID of the current process, link which can be indicated to point to child processes, return code
of the current process, also another field is the terminated children, which means dead child process.
- exit(n): to self-terminate with the return code of n, this system call doesn't return
- wait():wait for any child process to die, return will be the PID of any dead children
- exec(): because child process has the same codes and data as the parent process, by calling this function we can load different codes
and data into child process
- zombie states: some cases we need to keep track of PID and return codes of the process  even if it is terminated, the solution
is to introduce zombie state, which means that the OS cannot reuse the PID instantly, the child process will be marked as the
zombie state until the wait() system call gets the PID, then the process can be destroyed totally.
- case: what if the parent process has already quitted so the child process may be in the zombie state forever? <br>
It can be solved by process-1. The process-1 will wait and then release the related process and address space. a.k.a. reparenting

## Loading Programs into Process

Firstly we need to allocate new memory space for the program, then fork() so the new process is create, after we made sure the process
is the child process, we call execl() system call and load the program we desired to run in the child process. Then wait for the 
child process to finish and exit.

## Files 
- In Unix files are the abstraction of permenant data storage, which is seen as the extended address space for the current process.
- Using handler to access a file, the handler is not the file itself, but contain enough contexts for the program user to get access to the
file info
- standard file descriptors:
0 represents for stdin, 1 for stdout, 2 for stderr, whenever the process requests for a new file descriptor, the lowest file
 descriptor not in use will be selected.
- I/O redirection: e.g. primers 300 > '/User/cedong/Output.txt' redirect the output to the given file
- file descriptor table: file descriptor can be used in user mode, but inside kernel we got a file-descriptor table, which is
an array and descriptor is the index, which points to another kernel data structure, system file table, we record info like
 access mode, file location, how many handlers points to the same file and index node pointer(the file's full info is stored in 
 the inode kernel data structure)
- access control: three different types owners|users|others and three types of access: read|write|execute
- execute: indicates whether the user can trace the path from root to the current file location
- pipes: sender has a write descriptor to a buffer and receiver has a read descritor from the same buffer, a.k.a. pipes
- directories: structure like a tree, hard-links and soft-links
